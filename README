This is a prolog interpreter written in C by Xian Ran (xianran@pku.edu.cn)

请在 Unix 系统上编译和运行这个程序

依赖：gcc，make

编译：make clean && make

运行 cwam。在本目录下有 1.pr 到 6.pr 六个文件，分别是测试用的 prolog 程序。
以程序 5.pr 为例，执行及执行的结果如下所示，其中 % 开始的行是解释器的输出。
这个程序的目的是为了拼接两个列表。

This is XR's prolog interpreter
Type help to get help
?- consult('5.pr').
YES.
?- list.
  0:	      query$: trust_me
  1:	              put_constant '5.pr' A0
  2:	              call consult
  3:	              halt
  4:	    concat~1: try_me_else concat~2 (11)
  5:	              allocate
  6:	              get_constant [] A0
  7:	              get_variable Y0 A1
  8:	              get_value Y0 A2
  9:	              deallocate
 10:	              proceed
 11:	    concat~2: trust_me
 12:	              allocate
 13:	              get_variable Y0 A0
 14:	              unify_list Y3 Y1 Y2
 15:	              unify_variable Y0 Y3
 16:	              get_variable Y4 A1
 17:	              get_variable Y5 A2
 18:	              unify_list Y7 Y1 Y6
 19:	              unify_variable Y5 Y7
 20:	              put_value Y2 A0
 21:	              put_value Y4 A1
 22:	              put_value Y6 A2
 23:	              call concat (4)
 24:	              deallocate
 25:	              proceed
?- concat(X, Y, [a, b, c]).
YES.
X = []
Y = [a, b, c]
more? [Y]es, [N]o
y
YES.
X = [a]
Y = [b, c]
more? [Y]es, [N]o
y
YES.
X = [a, b]
Y = [c]
more? [Y]es, [N]o
y
YES.
X = [a, b, c]
Y = []
more? [Y]es, [N]o
y
NO.

备注：这是北大编译实习实验班的作业，由于时间紧张，有一些细节尚待完善，如不友好的报错和
错误处理机制等。请勿在我不知情的情况下传播任何代码、可执行文件。
